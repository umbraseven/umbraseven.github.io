---
layout: post
title:  "重构与设计"
date:   2020-06-11 17:06:00 +0800
categories: 计算机科学
tags: 设计 
description: 
---

*  目录
{:toc}

***
又一次读《重构》，随手记下一些零零碎碎的想法。

## 关于设计

### 重构与设计

作者非常推崇设计模式。“软件自有其美感所在”（这句我赞同），有结构的美、解构的美、重构的美（这个总结我同样很赞同）。结构的美是对完美理型的向往，解构的美是在实际中用迭代的方式从混沌中找到一条路，重构则联系了这两者。

我喜欢这种解读。我想设计和重构的最终目的，都是追寻那种结构的自然美感，但是复杂、多变、未知、混沌的现实，并不允许我们从起点直接传送到终点，我们不得不一步一步攀登，将设计与结构这个大的整体，分离到每一步的设计里，逐渐去逼近、完成它。


重构与设计是何关系？作者的一个观点是，重构改变了预先设计的角色。如果没有重构，我们就必须保证预先设计的绝对正确，而这几乎不可能。引入重构之后，我们只需要做出“大概良好”的设计，不完善的地方，我们可以在code和refactor的过程中不断调整优化完善。

什么是“大概良好”？就是重构起来不要过于困难……

在这种方式下，能避免“预先设计”容易引入的大量过度设计。我们可以从最简化系统入手，随时调整，在需要的时候进行重构，使得它能时时满足当下的需要，既不欠下太多债务，又不对未来做过度投资。


我认为重构是小粒度的设计，是受限的、局部的设计，但它指向的方向是前后如一的。

***
### 设计与抽象：分层、分模块

良好的设计与抽象，可以为软件后期的开发、维护、扩展，节约大量的时间。为何？因为在良好的设计里会分为很多层次，很多模块。而每一个层次、每一个模块里，都是简洁、完整、准确的。

所以，我们对于每一个层次、每一个模块的思考和修改，都是在一个很低的复杂度下进行，因为只需要考虑当前层次的问题。

比如这次做的物联网框架，当我们替换一个网络节点时，在我们的设计中，是对象挂载到节点的某个端口上，节点再连接到网关。当我们要执行替换时，只需要建立一个新的节点并连接到原网关，再将之前的设备集迁移到当前节点，之后再删除掉原节点。其他的细节我们都不需要考虑，我们只需要在这个层次上进行思考和操作，这就非常简洁。

如果没有进行抽象和封装，没有良好的设计，那这一个操作会贯穿整个软件架构，会涉及到无数细节，可想而知这会多么困难，多么容易出错。

***
### 重构与重复

让所有事物和行为在代码中只被表述一次，这是优秀设计的根本。这种设计是方便修改的，因为只存在于一处，那么当它发生变更时，我们也只需要修改一处。

***
## 关于重构

基本定义：重构是在不改变软件可观察行为的前提下改善其内部结构。

### 重构是“小”的热爱

重构是对小的热爱。重构本身是对设计的解构，从小入手，自底向上完成“结构之美”。

重构的每一步，都尽可能小。因为小，所以不复杂，能轻易发现错误。

重构完成的结构里，推荐各种小玩意：小的自定义数据结构（比如相关联、或者总在一起变化的两个字段所组成），小函数（实现单一功能），小类等等。


***
### 重构的风险

>代码被阅读和修改的次数，远远多于它被编写的次数。保持代码易读、易修改的关键，就是重构。

但是重构会引入风险，尤其是当代码混乱到必须重构时——而这怕是每一个重构者经常需要面对的问题。当我们评价一份代码必须被重构时，它大概是内部如乱麻，牵一发而动全身，以至几乎不能维护了。

所以重构是危险的。如果随意进行重构，不对自己做限制，那只会让自己陷入泥潭。“重构必须系统化进行。”

我想在重构里，重要的不是灵感迸发、大刀阔斧，而是谨小慎微、稳步前行。

***
### 重构的时机

什么时候开始重构？

当你需要为程序添加一个新特性或者新功能，而代码的结构使你无法很方便地达成目的，那就先重构，再添加。这也就是所谓的“坏味道”。

有一个“三次法则”值得借鉴：事不过三，三则重构——第一次做某件事时只管去做；第二做时会产生反感，但无论如何还可以忍受；第三次则必须重构。


什么时候不应该重构？

如果代码已经乱到无法拯救了，重构的代价甚至远高于重新编写，那就直接重写吧，不受这气。

如果代码有很多bug，导致根本无法稳定运行，那也就直接重写吧，不受这气……

***

***
## 重构的技术

### 重构与测试

重构的本质：由于每次修改的幅度都很小，而且每一次修改都会进行测试，所以任何错误都很容易被发现。

重构需要做的第一件事是什么？搭建测试环境，完整、可靠的单元测试环境。为了降低测试成本，测试程序必须具有自我校验的能力，让我们能用非常非常简单的方式运行并作出结果判断，这样我们才可以在重构中随时随地进行测试，反反复复地执行测试。这非常重要。

“类应该包含它们自己的测试代码。”这个观点非常好，每个类都应该有一个自己的测试函数，并以它来测试自己这个类。

什么时候添加测试代码？最好的时机是在开始编写功能代码之前，因为这是在反问自己，我到底是为了实现什么？需要向外提供什么样的接口？外界可能有哪些输入，有哪些边界情况？

测试代码会给我们的任务一个明确的指标：当我们的代码能完成测试时，我们的工作也就完成了。这非常好。


在编写测试代码时，还有一个有趣的问题是，如何测试测试代码？有时候我们要故意让自己的代码出错，看测试代码能否准确地发现错误，以此来确定测试单元的可靠性。

我们需要测试什么？所有的函数吗？

不不不，并不是测试得越多越好。如果你对每一样东西都进行测试（尤其是如果包括了那些你一眼望去就知道根本不会出错，测试它只会让你昏昏欲睡的部分），那么你一定任何一样东西都测试不好。测试的东西越多，测试量就越少，不要把测试搞得太过于重量级，让人望而却步。

我们应该优先测试那些最容易错的部分，那些我们期望从测试中获得最大收益的部分。“编写未臻完善的测试并实际运行，好过对完美测试的无尽等待”。

以这个原则来推导，我们在测试时要格外关注那些“边界条件”，因为它们往往是最容易犯错的地方。如果所有的边界条件都能正确运行，那内部大概率也能正常运行。注意，边界条件不只是数值的边界，同时包括了那些极端情况、异常情况。比如读文件时遇到空文件之类的。


我想，测试最核心的思想就是，不要期待用测试找出来所有的bug，而是用最方便的测试方式，找出大部分bug。对完美的渴望有时候会阻止我们迈步，而前进最重要的，就是一步一步迈出去。

另外，对待测试代码和产品代码是不同的。测试代码我们尽可能随意处理，复制粘贴删减乘除都无妨，因为它们相对独立。


***
### 命名与注释

变量名有多重要？写出计算机可以理解的代码并不困难，写出人类容易理解的代码才是优秀的程序员。好的命名非常必要。一个好的函数名字，让我们不用进入函数就能知道它所完成的功能，读命名良好的程序，会让我们感觉自己在读一份非常流畅、省去了细节的伪代码，能大大提高程序的可读性。而坏的命名简直就是灾难。

一个有趣的观点是，如果你觉得需要给代码加一点注释，那就为这一部分代码建立一个函数，同时用良好的函数名来代替注释。


***
### 小粒度的例子：函数

追求小粒度。为何？易复用、易覆写、使高层函数易理解。关键点在哪里？函数名。

特别值得注意的是，提炼函数不仅仅是为了函数的复用，还有一个非常重要的目的是清晰度，甚至还可以因此牺牲一些性能和长度。

***
### 两顶帽子：重构与添加

重构和扩展二选一。

不要两者同时进行。重构的基本定义就是不改变程序的可观察行为，只改变其内部结构。这样就可以用定义好的测试接口来检测其错误，给予约束。一旦放开这个基本原则，重构会变得不可控。


***
## 重构的收获

### 重构与债务管理

这是一个非常有趣的观点：在软件开发工作中，未完成的重构工作（代码结构的“坏”）可以被视为债务。我们可以通过透支债务去追求更快的开发进度或者更有效的运转迭代，但我们会在之后为债务不断支付利息。如果债务越来越多，庞大的利息甚至会将我们压垮。

以此为延伸，我们可以作出如下判断：适当的借贷在某些场合是必须的。在上一个句子中，最关键的词是“适当”。

***
### 重构与理解代码

“我不是个伟大的程序员，我只是个有着一些优秀习惯的好程序员。”对代码的理解，可以帮助我们找到bug，而对代码进行重构，有助于我们理解代码，重构的过程，某种意义上就是思维逐渐展开、抽象逐渐成型的过程。

重构是一种自底向上理解代码的方式，而设计应该是自顶向下，不断完善的。我个人而言的话，并不倾向于任何一边，我认为过犹不及，必须两者兼顾。也就是既要有一定的整体性设计，又可以在重构中完善对于整体框架的理解，进行补充和优化。

或者说，设计本身就是基于细节的。只有对底层有足够深的理解，才可以作出自顶向下的设计，两者并不相悖。


***
### 重构与开发效率

良好的设计是快速开发的根本。

***
## 重构的难点

### 接口与数据库

这是阻拦重构的两大难题。现在的很多软件的数据存储都是基于数据库的，对象与数据库表格之间有对应关系，会使得重构难以进行。可以考虑的方式是增加一个间接层。（计算机科学里，没有什么问题是不能通过增加一个间接层来解决的，如果有，那就增加两个。）

其次就是接口。如果接口已经发布（被别人引用，所谓的别人就是我们控制范围以外的别人），那么接口的所有权就不再只是你一个人了，这会给修改带来很大的困难。（代码的“所有权”概念很有意思）


***
### 重构与性能

重构时不考虑性能。重构时只关注程序结构如何更合理、清晰、优美、易读，不关心性能。即使它会导致一个循环被多次计算，也大可不考虑它。那是性能优化时才需要考虑的事。比如在重构中会做的一件事是尽可能消除临时变量（临时变量会导致程序冗长、混乱），用查询函数的方式代替（这会导致重复计算）。

事实上，重构会让我们写出更快的代码。因为良好的代码结构使得我们在做性能优化时更好调整。

***
### 重构：不以理解代码为前提

从“不改变软件行为”，到“不需了解软件行为”。在真正难度大的重构中，代码之混乱，使得我们了解代码都变得不可能，或者说这正是重构的目的——只有通过重构，我们才能更好地了解代码的结构与含义。

所以，“理解代码”可能要发生在重构之后，而不能作为重构的一个前提条件。这非常有意思。但这如何可能？

模式。通过某种被证明绝对安全的模式，对代码本身进行调整，而不涉及其含义。（我对于这个观点目前还持观望态度，但这观点本身确实很有意思）而这需要我们不只了解重构的思想，还需要深入具体的手法，在实践中形成某种直觉，能感觉出代码的“坏味道”，并且熟练掌握对应的重构手法。（我对于坏味道这个形容很赞同）


***
### 重构与节奏

>这些似乎如此精彩，可它们却仅仅是个开始，这是为什么？答案很简单，因为你还不知道何时应该使用它们、何时不应该使用；何时开始、何时停止；何时前进、何时等待。使重构能够成功的，不是前面各自独立的技术，而是这种节奏。

不能更赞同这一段话了。这才是重构真正的难点，也正是重构的迷人之处。重构的本质性困难在于设计，而设计属于“可感的世界”，而非“可知的世界”。

