---
layout: post
title:  "程序的编译、链接、装载"
date:   2020-06-11 16:00:00 +0800
categories: 计算机科学
tags: 计算机科学 编译原理
description: 
---

*  目录
{:toc}

***

## 目标文件的生成

### 预处理和编译

最开始是预处理。

* 这是一个很有C特色的阶段，会出现的原因也是由c语言的编译特性决定的——c语言的编译是基于单个文件的，所以每一个要编译的c文件都必须是完备的。而我们编写的时候，又无法接受这种完备。比如某个数据结构定义，如果要完备，那么必须在每一个c文件里都出现；而编程法则告诉我们，一个东西一旦存在两份，就会有编写和修改时的错误风险。所以编程的时候是非常忌讳冗余的。

* 为了达成既完备、又不冗余的目标，我们需要有一种方式，让我们在编程时可以只写一份，但在编译之前又能合理地分配到各个c文件去，让它变得完备起来。这就是预编译。预处理过程里，有几个非常典型的命令：一个是宏定义#define，一个是条件命令#if，一个是引用命令#include，除了处理这些相关命令之外，还会做一些方便编译的其他工作，比如去掉注释，添加行号之类的。

* 在预处理结束之后，会得到一个.i文件，它同样是纯文本文件，是一个单独的、完备的c文件。如果我们想要确认自己写的宏，自己的头文件包含是否正确，那可以生成中间的.i文件，并用文本编辑器查看。

* 编译是从c语言编译为汇编.s文件。这是最核心、最复杂的一步。这个过程大概可以分为词法分析、语法分析、语义分析、优化、目标代码生成等步骤。汇编则是用汇编器，将汇编代码汇编为机器代码，从.s文件变为目标文件.o。代码的翻译是非常简单的，因为一句汇编对应一句机器码，不需要那些复杂的分析过程。值得注意的是，目标文件有不同的格式标准，比如linux上通用的elf格式。

***
### 编程语言的发展：地址、符号、变量

当我们想理解一个语言特性的时候，不妨沿着语言的发展往前看，看它为何会出现，在什么样的背景下，根据什么样的需求而出现。

* 最原始的编程语言可能是穿孔纸带，这是一种机器码。比如一个指令为一个字节，8位，那么可以约定前面几位表示指令，后面几位表示操作数，用是否穿孔来表示0或者1。

* 但是这种方式有一个大的缺陷：地址引用问题。当我们要操作一个中间状态（不管是取值还是存储值），或者我们需要执行一个跳转时，我们需要将它的地址明确写在指令里。它所导致的一个后果是，如果在将来程序有改动，可能所有的地址都需要手工做一次改动。这无疑是极为繁琐，且容易出错的。

* 汇编语言很好地解决了这个问题，虽然它在指令上只是机器码的一对一翻译，但是它引入了“符号”的概念。我们可以用一个符号来代表一个地址，并且在汇编时，计算机自动计算出符号的最终地址，写进机器码。这个过程，就是最古老的重定位。

* 最开始，我们对符号的使用可以分为两类：指令的地址与数据的地址。我们对于指令地址的使用，一般用于跳转；我们对于数据地址的使用，既可能是取得地址中存储的值，也可能是往地址中写入值。就后者而言，这个符号似乎代表着一个实体的存在，有它的值，也可以写入新的值，这就是高级语言中的变量了。

* 所以变量的出现，其实是自然而清晰的：在汇编代码里，无非就是手动开拓出一块空间，用一个符号命名它；之后要使用的时候，再借用这个符号来操作，以进行汇编时的重定位；再往后的高级语言里，则添加了更多的特性，使得在编译时可以完成类型检查等额外的工作，使得“变量”的含义更加广泛；再发展，面向对象技术的兴起，变量被赋予了“灵智”，数据和操作合为一体，成为一个“有着自己方法”的“对象”。

* 随着语言的发展，编程变得越来越简单，程序变得越来越大，很多大型的项目有上百万行的代码，需要很多人合作开发和维护。这个时候会出现两个问题：一个是代码的重用；一个是代码的模块化。

* 在代码的重用上，各种语言各显神通，对于c语言，代码的重用主要是函数和数据结构。在代码的模块化上，c语言是以单个的c文件为模块的，模块之间进行交互的是变量和函数，当编译为目标文件以后，在机器码的形式上，变量和函数都是地址，可以用符号代替。所以模块与模块之间，需要沟通商量、确定最终形式的，就是符号所代表的地址。

* 而链接，核心任务就是解决符号和地址的问题。

***
### 目标文件与格式

不同平台的目标文件有不同的格式，比如Windows平台的PE（portable executable）和Linux的ELF（executable linkabke format），它们都源自于COFF（common file format）。所以pe和elf在文件结构、数据分布等很多方面是非常相似的。

目标文件大概可以分为以下几类：
* 可重定位文件：编译之后，静态链接之前的文件。linux/windows下分别是.o/.obj文件；对它们进行归档（tar），就得到了静态库文件，分别是.a/.lib文件。
* 共享库文件：编译之后，可以直接装载，用于动态链接的文件；linux/windows下分别是.so/.dll文件。
* 可执行文件，静态链接之后，可以直接装载、执行的文件；linux下没有后缀名，windows下是.exe。
* 核心转储文件。

对于linux而言，这四类文件都是目标文件，都是elf格式。尤其是对于可以装载的可执行文件和共享库文件，本质上没有任何区别：都是装载，根据段分布进行内存映射，转交给程序入口点……事实上，某些共享库文件本身就可以作为一个独立的可执行文件来运行。

***
### elf文件结构

coff文件提出了分段机制，这种机制被pe和elf所沿用。在elf文件中，数据是以段（section，也称为节，有时也会称为segment）来存储的。

* 在一个典型的目标文件里，程序编译完，需要载入计算机内存的几个部分无疑是最核心的，比如.text/.data/.bss段，这些都是我们所熟知的。除此之外，为了能完成链接、装载等一系列工作，还有很多辅助的结构。

* 首先是文件头elf headers。如果我们以os角度来观察的话，文件头无疑是极为重要的，因为在linux中所有文件可以随意更改后缀，所以os在看文件头之前，无法确实知道文件的类型。在文件头里，会有很多os用来进行验证、匹配的数据，比如魔数magic number，比如这个文件需要的硬件支持、版本等。

* 同时，os还需要根据文件头的信息，进而获得整个文件的信息，知道如何在文件中找到自己所需要的段。所以在文件头里，包含有文件包含的段数量，段表在文件中的偏移，段表字符串表在段数组中的索引等等。

我们可以想象os是如何寻找的：
* 当它需要找到一个名为.text的段时，它可以先找到段表，然后遍历段表中的每一个seciton header，用其中包含的段名字符串索引到段表字符串表里找到相对应的字符串，和.text一一对应，直到找到相符合的段。

* 如果要避免这么低效率的搜索，那也许我们还可以建立一个段名的hash表，以段名为index，得到该段在段表中的下标……

* 那文件头是怎么创建的呢？当然是用一个数据结构创建出来的，其中的数据可以和实际elf文件中的完全对应起来：

```c
typedef struct{
    unsigned char_eident[16];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32_Half e_phentsize;
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
} Elf32_Ehdr.

```  

* 另外因为elf格式要兼容几种文件，所以某些数据结构在应用于某一特点类型时会有冗余。比如ph表示的是program header，程序头，这是只有可装载文件才需要用的属性。


***
### 段与段表

一个段，我们将它分为两个部分：段头section header和段本体。

段头里保存了和段相关的各种属性信息，比如段的大小size，文件内偏移offset，虚拟空间地址vma，占用文件空间大小，对齐algn，类型type和标志flag等等。

如何描述它？那当然是建立一个数据结构：

```c
typedef struct{
    Elf32_Word sh_name;    
    Elf32_Word sh_type;
    Elf32_Word sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off sh_offset;
    Elf32_Word sh_size;
    Elf32_Word sh_link;
    Elf32_Word sh_info;
    Elf32_Word sh_addralign;
    Elf32_Word sh_entsize;
}     Elf32_Shdr;
```
每个section head40个字节，非常标准。为了方便查找，把它们集合起来放到一起，就变成了一个数组，这就是section headers table，也就是我们常说的段表。从文件头就是先找到它，再根据它来找各个段。

其中有很多内容值得被讨论一下：

* 段名sh_name，因为字符串长度不可控，为了数组的规整，所以将所有的字符串存储在一个单独的段里，在sh里只放索引（注意，这里的索引其实是段表字符串段的偏移地址，对应到字符串的第一个字符，而字符串结尾有/0，所以不需要指定有多长。所以这里用“索引”表述并不合适……如果要用索引的话，应该是有一个char\* 数组，用索引拿到char\* 指针，再用这个指针拿到字符串……）。

* entsize是可以忽略的细节：在某些段中，是包含一些项，每个项大小一致，相当于这里就是给定单个项的size。

* sh_addr，虚拟地址。用以指明这个段需要被加载在内存中的哪个位置。如果是.o目标文件（不可加载），那这个数值是0。

* 段的类型和标志位。段的类型有很多，标志位没几个。标志中，典型的有write/executable/alloc，第三个表示会被加载进进程空间。

* sh_link和sh_info，这是两个根据type不同而有不同含义的字段，貌似这种方式在内核编程中挺常见的 。比如对于重定位段.rel.text，它的sh_info表示这个重定位所用于段（也即为.text段）的索引。

每个段除了seciton header之外，就是seciton body了，也就是各个段。值得注意的是，段里只有纯粹的内容，没有任何的属性说明。比如代码段就是纯粹的代码，数据段就是纯粹的数据。
  

***
### 有哪些段？

段数量很多，作为一个闲人，可以都看一看：

* .text/.data/.bss/.rodata 这是代码段和数据段。其中有很多值得讨论的点。
  * .bss段很特别。它里面存储的是未初始化的全局变量和静态变量。因为没有初始化，那它的默认值就是0；既然这样，虽然在装载到内存时需要分配空间，但是在可执行文件里就没必要了。所以elf的做法是，声明它的长度，但是不实际占用可执行文件的长度。
  * 这里必须要区分的一个概念是：可执行文件中的存储和进程虚拟内存的存储。可执行文件的根本目的还是为了之后在被执行时装载进内存，在文件中的存储方式和在内存中的存储方式有一定的相似性，但并不完全一样。
  * 对.text和.data段区分有很重要的现实意义：比如保护、缓存命中，而其中最重要的一点是，代码段可以被设置为只读，只读是可以被共享的。这可以为计算机节省大量的内存空间。
  * .rodata段，某些const全局变量会放到这个段里，装载的时候好放入只读区里。

* .comment段。这是注释段，显然，如果不开启debug的话，正常模式下它们不需要装载，没有alloc标志。

* .debug段。调试相关。实际上如果开启了debug，会有很多奇奇怪怪得段加进来。会使得可执行文件大小变大很多。

* .dynamic段。动态链接相关段，如果是共享库，会有更多的类似段。需要加载进内存。

* .hash。用于字符串的哈希查找。需要加载进内存，运行时看来也需要查表。

* .strtab。字符串表，如果有需要就会加载。

* .symtab。符号表，如果有需要就加载。

* .shstrtab。段表字符串表，其中很多是段名，不需要加载。

* .line/.note。行号，以及其他的一些记录。

* .plt/.got。延迟绑定/全局符号偏移，和动态链接中的重定位相关。

* .init/fini。程序初始/结束代码段。比如C++全局对象的构造和析构就是在这个里面完成的。

* 剩下的的还有很多奇奇怪怪的段，很多都是历史遗留问题，并没有什么实际意义。这也告诉我们，在学习计算机科学这种工程性非常强的学科时，要保持好奇、多思考，同时也要多查资料，不要钻牛角尖，因为很多问题都是工程问题，有着强烈的路径依赖。也许你使劲纠结一个数值为什么要这样设定，但那只是当时环境下的巧合或者无奈之举。

***
### 符号symbol

符号symbol与符号名name不同。符号在这里的含义更类似于“变量”或者“对象”。符号有多个属性：

```c
typedef struct{
    Elf32_Word st_name;
    Elf32_Addr st_value;
    Elf32_Word st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf32_Half st_shndx;
}Elf32_Sym;
```

关于数据结构的说明：
* name是字符串表中的索引，和段一样；
* size表明存储空间大小；
* info表示出符号类型和绑定信息，比如符号类型有object/func/seciton/file/notype等，绑定信息则有local/global/weak等；
* value根据类型，可以解释为地址或者数值；
* shndx是符号所在段的索引，如果是文件，会是ABS；如果是外部符号，会是UND（undefine）。

关于符号的地址：

* 在我们编写一个c程序时，比如调用一个函数，我们是没有指定最终的绝对地址的，仅仅是 func()；在汇编代码里，同样没有指定绝对地址，而是call func；这里func成为了一个符号；但是在最终的机器码里，给cpu取指执行时，是必须要最终地址的（相对地址/绝对地址）。

* 如果func是一个局部符号，那它的地址很容易算出来：比如它在.text段中的偏移量是0x100，我们可以用相对地址调用来call，或者也可以根据.text的默认载入地址来计算；如果func是全局符号，是extern的，在外部定义的，那这个地址在编译的时候，连相对地址都拿不到了。

* 特别注意的是 ，即使是局部符号，它的绝对地址在编译时也是不可知的——因为你不知道当前c文件会在最终可执行文件的哪个位置。编译仅仅产生.o目标文件而已。这个最终地址的确定，要等到静态链接时，此时生成了可执行文件，拿到了全部的符号，也明确了最终在进程虚拟空间中的分布。

* 所以，对于静态库的符号，是链接时确定其地址的。但对于动态库，在链接时并不参与，所以需要等到装载时才能最终确定，那就要复杂很多了。


另外，还有一些有趣的点可以讨论一下：

* 特殊符号。除了我们在程序中所声明的符号之外，编译器和链接器也会定义一些特殊符号，加入到符号表中；我们可以直接在程序中引入并使用。这游戏类似于在预编译阶段，可以根据是否define了__cpulsplus来分辨是否是c/c++代码一样。

* 符号修饰。c语言的命名空间非常简单，所有的全局变量都在同一个命名空间里，这使得全局符号非常容易起冲突。
  * 因为一些历史原因，c语言还引入了符号修饰的功能：所有的变量在经过编译后，名字前面都会加入“_”；这个传统目前也会引发不一致性，比如在linux和windows下就可能不同。而一旦编译器的符号修饰不同，那即使源代码一样，也会导致链接失败。
  * c++在这方面更为复杂，因为它支持函数重载——允许同一函数名有不同的参数列表。函数重载的实现其实就是通过编译器的符号修饰完成的，通过一定的法则，根据参数的数量和类型，更改函数名。这会导致严重的不兼容性：首先是和c的不兼容。为了保持兼容，我们可以在代码中如此处理：

```c
#ifdef __cplusplus
extern "C" {
#endif 

/* 实际代码 */

#ifdef __cplusplus
}
#endif 
```

* 强符号和弱符号：
  * 在c/c++中，函数和被初始化了的全局变量为强符号，未被初始化的全局变量为弱符号。
  * 同一名字下：强符号只能有一个；一强多弱时选强；多弱无强时，选占用空间最大的。

* 强引用和弱引用：
  * 对外部符号的引用默认为强引用，但是可以手动用__attribute__((weakref)) void foo()定义为弱引用。
  * 对于链接失败的弱引用，链接器不会报错，而是将它的地址置0。

* 为什么会有这么奇怪的强弱区别？
  * 那是因为公开发行的共享库。强弱符号的区别，允许库将自己的函数定义为弱符号，可以被客户所定义的强符号所覆盖，实现类似于覆写的效果。
  * 强弱引用的存在，可以让程序在依赖一个库时，如果库发生了变化，接口不存在了，依然可以顺利运行。只是在调用之前，需要先进行地址判定，如果是null就不执行这个函数了。

***
### 静态链接

生成.o目标文件之后，它们还是孤立的，还不是一个整体，无法装载与运行。下一步就是如何将它们链接起来，形成一个整体。而链接的接口，就是符号。静态链接的主要工作可以分为两部分：
* 其一是如何将各个.o文件的段落组合起来，并合理分布地址空间，确定符号地址；
* 其二是如何将各个.o模块的符号整合起来，解析决议，并根据前一步确定的地址，完成数据段、代码段的重定位工作。

***
**空间与地址分配**

* 对于空间，我们时刻需要牢记的是有两个不同的空间：可执行文件中的空间与进程虚拟地址空间；在大多数情况下，它们的空间分配是趋于一致的，这样装载映射起来也更加方便；这两者中，我们更关注进程地址空间，它是根本的，可执行文件的构成、分布都是为了最终程序的执行而服务的。
* 空间分配有两种可能的策略：文件按序叠加，或者是相似段合并。前者处理简单，后者则会给进程运行带来很多的好处，比如方便管理、缓存命中、段落合并、代码共享等等。所以一般都是用后者。
* 空间分配完成后，各个段落的地址就确定了（段落包含了数据段和代码段，所以数据的地址确定了，也就是符号的地址确定了）。在这个过程里，应该是会涉及到符号决议的——比如强弱符号的判定与选择之类的。在这一步完成后，所有的全局符号都将一一对应上，不多不少。
* 最后是重定位。符号地址确定以后，这一步是非常简单的，只要将需要重定位的符号一一刷过去就行了。为了完成这个操作，需要提供什么？重定位的入口地址（相对于段首的偏移）、符号（取到符号的地址值）、修正类型（相对跳转和绝对跳转的修正方式就不一样）。这就是重定位表需要提供的，而且是每个需要重定位的段都会对应一个单独的重定位表（一个重定位表就是一个单独的段）。


***
一些其他的讨论：

**common块**

首先是common块问题。因为有强弱符号的关系，在编译成.o目标文件时，对于未初始化的全局变量（弱符号），我们无法得知它最后是否会被覆盖掉。所以就不知道它最终会占用多少空间。所以给它分配.bss段并不可行。这个时候可以先把它标记为common块，在链接时符号决议之后，再放到.bss段去。

***
**ABI**

然后是ABI问题。API是Application Programming Interface，ABI是Application Binary Interface。也就是二进制接口。API更多的是关注的上层接口的兼容性，实现软件的封装与分层；ABI则更多关注底层机器码的兼容性。

事实上，ABI的兼容比API更加困难。C语言上，典型的ABI兼容问题有：内置类型和存储方式（比如大小端、对齐方式）、组合类型的存储分布（比如struct、union、数组）、外部符号的解析（比如符号修饰）、函数调用方式（比如参数入栈顺序、返回值如何保持）、堆栈的分布方式（比如局部变量在堆栈中的保存方式、参数传递方法）寄存器使用约定（哪些可以修改、哪些需要保存、调用方还是被调用方负责等）。

C++就更麻烦了，比如继承类体系的内存分布（比如基类、虚基类在内存中的位置）、虚函数和虚表的内存分布、全局对象的构造和析构、标准库的实现、异常机制……

gnu组织为了让这一切不那么混乱，弄了个BFD（binary file descripter）库，大概意思就是elf文件都交给我来处理，你们编译器、链接器或者其他什么的，都只需要调用我这个就可以了。这样如果要添加新的文件格式或者更改，只需要改这个bfd库，很方便。

***
**静态库**

静态库是.a文件，本质上就是对.o文件进行打包，方便管理。在系统提供的静态库里，基本是一个函数一个单独的.o文件，这么做是为了尽可能减小可执行文件的大小，避免把一大堆不需要用的函数链接进可执行文件里。（注意：链接静态库时，可不会只“挑”我需要的函数，静态链接器对所有.o文件一视同仁，没这个分辨能力）

而且可执行文件中的内容是会实实在在的载入最终的进程空间占内存的，它们还不会被共享，所以就需要格外节省了。

***
## 装载与运行

得到可执行文件之后，下一步就是如何让这个程序运行起来了。linux运行一个新的程序，是通过fork()和exec()两个系统调用来实现的。前者产生一个新的进程，但是是父进程的复制体；后者用映像文件（image file，也即是可执行文件）进行填充。

所以，装载是成功运行程序的第一步。装载的过程就是如何用映像文件填充进程地址空间的过程。

***
### 进程虚拟地址空间

这是一个很大的话题，我们只能尽可能简略地聊一聊。进程虚拟地址空间是随着分页机制的出现而出现的内存管理方式，有着很多优点，其中最显著的几个特点是：

* 每个进程独占一个地址空间。在linux0.11的时候，一个程序只能分到64m的虚拟空间；而现在是完全的独占。这使得对地址空间进行隔离、保护、约束都很方便。

* 虚拟内存空间只依赖于映射结构（页表结构），而不依赖于实际的物理内存；对进程只需要保证在它需要的时候，可以拿到它想要的数据就可以了。

* 将内存以“页”为单位进行管理。

* 上述两者可以得到很多强大的特点：程序要求的虚拟空间的连续性经过页表映转换后，可以映射到离散的物理内存；页表这种转换机构配合swap机制，可以让页内容对应到磁盘，在需要的时候从磁盘换入物理内存，相当于是让物理内存作为了磁盘的缓存，而让计算机拥有了极大的内存空间。

* ……

***
### 装载可执行文件

如果以操作系统的角度来看，建立一个进程，就是为它分配好地址空间，建立好线性区映射关系（vma映射关系，使得虽然现在没有加载全部内容到内存，但是在之后在需要的时候，在page fault的时候可以对应到磁盘文件位置），移交控制权给程序指令入口。

linux装载的大概过程可以总结为：

* 读文件，分析elf文件头，验证各种信息，并拿到段表等基本信息。
* 建立进程地址空间，也就是建立映射机构——页表。事实上最开始只建立页目录表就足够了。
* 建立vma（线性区）数据结构。这是一个进程内存管理的至关重要的数据结构。vma里定义了各种段（segment），每个段有不同的类型、权限，这个段在磁盘中如何找到等等。vma的建立依赖于可执行文件，尤其是其中的程序头（program head）。
* 事实上，在可执行文件中，为了方便之后的装载，链接器会对section进行合并，尽量将权限相同的seciton合并在一起，形成尽可能少的segment。
* （静态链接下）加载完成后，默认将程序入口设定为_start，设置好堆栈，并利用iret指令跳回用户态，开始执行指令。
* 此时代码段可能还没有载入，会出发page fault，建立页表，触发换页，程序进入等待；访问磁盘文件，载入内存，ok后唤醒；调度成功，继续执行，开始执行第一行指令……


关于vma线性区：
* 进程装载后，典型的线性区有vma0/vma1（一般是根据读写权限合并后区分的）、堆区、栈区、共享程序段区（一个共享库一个区）……
* 关于vma的管理，是linux内存管理的核心部分，可以参考《深入理解linux内核》。
* 需要特别注意的是，页机制主要是操作系统对于页整体的管理，是独立于进程之外的；而进程内的空间管理主要依赖于vma。比如页的有效位、脏位、可访问位、读写位等，都是为os整体内存管理的某些功能服务的；而vma则只关注线性空间本身如何分段，如何分布，如何设定权限……

***
### 动态链接

如果世界上没有动态共享库，那故事到这里就完整了。但是这种静态链接的一个大问题就是，内存使用效率不够高。因为某些底层函数（比如glibc运行库）几乎被每一个程序所使用，那么它们会在内存中存有大量的拷贝。

我们可以想到的一种方式是：只存储一份代码，让不同的进程都可以访问它，反正代码是只读的，不影响共享。而这在虚拟内存管理下又更容易实现：这些代码甚至可以在不同的进程中拥有不同的逻辑地址/线性地址，只要最后映射到同一个物理页就可以了。唯一需要保证的是，这些代码是一致的、不需要做更改的。

动态共享库就是将这些需要在内存中共享的代码独立出来形成的库。但是它们还面临一些技术难题：
* 首先是动态库加载到进程的位置是不确定的，因为一个进程可能同时加载很多个动态库，它们的位置如果预先进行设定，则难免会出现冲突，更合理的做法是不做设定，在加载时哪里有空闲就加载到哪里。
* 动态库是会互相依赖的，如果大家都不知道预先会被装在哪里，那代码如何确定、如何保持一致性呢？对导入符号的定位，一定是需要等到装载时才可以确定的。而在装载时，如何进行重定位呢？
* 我们可以像对待可执行文件那样，弄一个重定位表，标记入口、符号、方式，直接更改。但是这种做法需要更改代码，这就意味着每个进程都不一样，就无法实现共享了。我们需要的是既能重定位，又能不影响进程间代码的一致性……

那是如何解决的呢？

* 首先，我们的工具是动态链接器（和静态加载器，比如ld相对应），它同样具备链接器的各种功能，比如符号解析、重定位等等。在我们载入可执行文件以后，就会对它其中的段进行分析，得到其指定的动态链接器。
* os完成可执行文件的映射之后，不再直接进行控制权的移交，而是先给动态链接器。动态链接器开始加载动态库（从可执行文件所依赖的库出发，用广度优先/深度优先的方式加载，直到所有依赖的库都加载完毕）。
* 一边加载一边建立全局符号表，加载完以后，全局符号表也建立ok了。（这里有一个特殊的点要讨论：静态链接时，ld如何知道一个链接失败的符号，是存在于动态库，还是错误呢？所以静态链接时也是要用到动态库的，只不过仅仅用它们的符号表来进行符号判定）
* 符号决议。符号决议时，会有一个优先载入机制——如果符号重复，先进来的符号将被使用，后进来的会被覆盖。这会带来很多麻烦。
* 重定位。


关键的一个问题是，如何实现重定位？

* 核心的思路是：充分利用相对地址固定这个特点；既然代码段不能动，那就把重定位信息放到数据段。即使是动态共享库，数据段也是各个进程独有一份的。
* 对于模块内代码的访问和跳转：这很简单，因为共享库内部的位置关系是保持不变的，在编译时就已经确定了，所以仍然可以用相对跳转来完成。
* 对于模块内数据的访问：和代码不同，没有一个指令可以支持相对位置数据访问，但是我们可以取巧，通过一个函数得到当前指令的位置，然后根据编译时的相对位置，得到需要访问的内部数据位置。
* 模块外访问（代码/数据）：在数据段建立一个got（global offset table）表，其中就放着导入符号（import symbol，也即是模块依赖的外部符号），在重定位阶段，因为所有的共享库都已经载入，符号决议已经完成，符号都有了明确的位置，可以依靠动态重定位表等信息，将地址信息填入got表。在运行时，先用访问模块内数据的方式跳到got表对应的符号位置，再从中读到地址后访问。（注意，got表和代码的相对位置在编译时就已经时确定的了）。


还有一些小麻烦：
* 因为符号决议中的问题（强弱符号/强弱引用/覆盖……），共享库中如何确定自己的符号可以最终胜出？如果无法胜出的话，那即使是在内部有定义，最终也需要到外部访问。确定胜出的时候已经是符号决议了，这个时候已经来不及更改代码了，而要实现got访问，是要更改代码的。方法就是——对这些符号全部用got的方式来访问。

* 这又会导致一个新的问题：大量的重定位。尤其在某些库里，大量的函数相互引用，这会导致程序刚启动时要等待大量时间，即使很多访问可能根本用不到。那怎么办？再添加一个中间层——plt，延迟绑定。在真正要访问的时候，再来进行绑定。实现的方式很巧妙。


* 动态链接器这货也是个共享库，它自己怎么把自己给弄进去？这是个鸡蛋循环的问题。所以它采用了比较巧妙的机制来实现自举。

* 显式运行时链接。某些程序是不能停机的，比如web服务器。这时候用动态的方式进行装载和断开会更适合某些功能的维护、更新。几个比较核心的参数：dlopen\dlsym\dlerror\dlclose。

***
### c运行库

装载完毕以后，程序开始运行。但是我们的程序是如何能运行的呢？它依赖于什么条件呢？

事实上，我们编写的c程序，几乎都要依赖于c运行库：

* 我们编写的程序，往往需要用到操作系统所管理的某些资源，比如io、文件等；这些功能是操作系统提供的服务，一般以系统调用的方式给出。对于类unix平台，有posix标准，对系统调用进行了c形式的封装。比如open、write、exit等。
* 但是系统调用是不具有平台兼容性的，比如linux和windows就完全不一样。如果我们基于操作系统提供的系统调用接口来编写程序，会碰到几个严重的问题：首先是接口过于简陋，很基础；其次是兼容性不够，没有可移植性。
* 解决这个问题的办法就是增加一个中间层：运行库。c运行库处于用户程序和系统调用之间，可以说基于不同的平台，向上提供了统一的编程接口。
* c运行库和c标准库的关系：c运行库的大部分内容都是c标准库制定的。c标准库只是意义标准，并没有规定具体的实现；c运行库的内容更全，比如多线程机制就不在c标准库中。
* 我们在编程时所引用的stdio中的printf，就是典型的c运行库提供的函数，它是对write的封装，在其中加入了缓冲机制，提高效率；同理的还有堆内存管理，系统调用接口是brk和mmap，c运行库提供的接口是malloc之类的，运行库会一次要一大块，再慢慢细分给程序使用。

***
### 初始化和堆栈

除了在运行时对运行库的依赖之外，程序在main函数之前、之后也依赖于c库。

比如：
* 在程序运行之前，os需要先布置好堆栈。比如将环境变量（字符串形式，比如：“path=/home/root\0"）、参数数组（字符串形式），环境变量指针数组、参数变量指针数组、参数数量存在于栈里。如果要移交给动态链接器，还要把给链接器的参数也放进去。
* 入口程序（比如glibc的_start)会做一些工作，比如全局变量的初始化、全局对象的构造与析构、堆/IO/线程等运行库相关的初始化工作，再转交给main。
* main执行完成以后，要返回到入口程序里，执行一些收尾工作。
* 所以实际上，入口程序是嵌套在main之外，将它包含的一个函数。在它的前后都有其他的工作要做。


其中的一个有趣的工作，是c++的全局对象构造与析构。这个工作必须在main之前完成，又会涉及到各个目标文件，那怎么办呢？

* 编译器用了一种非常巧妙的方式来形式最终的函数：在静态链接成可执行文件时，会严格按照一定的顺序，将某些静态库文件链接进去，典型的比如：crt1/crti/crtbegin/libgcc/libgcc_eh/……/libc/crtend/crtn。
* 根据相似段合并规则，如果我在每一个部分都都定义了一个叫abc的段，那这些段就会被放到一起，紧挨着。可以利用这个规则，来生成一些特殊的函数。比如在crti里放入init和fini的函数头部，在crtn里放入init和fini的函数尾部，把它们分别放到单独的段里；同时在我们的程序.o文件里，也生成这两个段，把全局构造放到init里，把全局析构放到fini里……这样最终的可执行文件里，就会产生一个由各个.o文件合并成的函数：init/fini。
* 这就是大概的初始化、收尾工作的做法，基于机器码的编译器hack……

***
### 栈的调用惯例

Calling convention（习俗、惯例、公约、协议……）

之所以会有栈的调用惯例出现，是因为函数的调用自然地分成了双方：调用方和被调用方。两者要对调用过程配合紧密，有着一致的理解，才能成功完成。

这个约定就是调用惯例。如果全世界只有一种编译器，那么这个惯例可以不显于人，让编译器悄悄地处理掉；但是世界上语言很多，编译器很多，函数调用又很有可能发生在不同的模块之间，所以了解这种惯例就变得重要起来。

**调用惯例主要涉及什么？**

* 参数入栈顺序及传递方式。
* 函数符号名修饰规则。
* 谁负责清理堆栈。

**常见的c语言调用惯例**

* cdecl：调用方清理堆栈、参数从右至左入栈、符号名前加下划线。
* stdcall
* fastcall
* pascal


**返回值传递**

* 我们知道，函数的返回值一般都是通过%eax寄存器进行传递的。有一个问题是，如果返回值是一个struct，或者是一个c++对象，%eax装不下，该如何传递呢？

* 自然的想法是，%eax里只存放对象的指针，在函数调用返回后，调用方负责将其中的数据取出来，赋给需要的对象。

* 这大概就是真实的做法，需要在代码上玩一些小花招：在调用之前，先在栈上开辟出一段空间用于存放数据，并将指针传入（作为隐藏参数）；在函数调用中，得到数据后存入指定的空间，并将地址写入%eax；返回后，将数据写给对象。

***
### 共享库的管理

这是一个额外的话题（大概浏览，到实践中去体会吧）。

**版本管理**

共享库的版本管理是一个典型的工程问题，有着工程问题具有的特征：繁琐、易出错、枯燥……

共享库的机制决定了：
* 创建者和使用者往往不是同一个人。
* 使用者很多，而且分布在网络上的不知名处。我们可以充分地假设共享库的每一个导出符号都会被使用者使用到。
* 当创建者对共享库进行更新升级时，可能会引起不兼容问题。

那怎么样的更新会导致版本之间不兼容呢？对已有导出符号的更改，比如删除、更改形式、更改功能等，都会导致不兼容；而增加新的导出符号不会导致不兼容。

所以，共享库的版本管理的核心思路是：
* 通过某一种命名方式，让人们可以轻易地区分哪些版本与版本之间是兼容的，哪些是不兼容的。
* 在发布时，严格按照该命名方式来。

约定规则是：
* 主版本号：主版本更新是大改动，完全不具备兼容性；如1.83与2.11。
* 次版本号：增加新的功能，不更改已有接口；向后兼容，但不向前兼容。比如2.11与2.21。
* 细分支：完全兼容，只是为了修复bug、优化维护之类的，不影响功能。

SO-NAME：
程序中一般只记录库名字和主版本号，比如libfoo.so.2。它一般都是一个指向实际库的软链接。当库更新时不需要更改各个记录的程序，只需要将软链更新一下就可以了。

共享库查找过程：
* 默认的查找路径有/lib,/usr/lib,/usr/local/lib。分别是系统核心库、非核心库、第三方库。
* 我们还可以手动在环境变量中添加查找路径。这个路径会被优先查找。

***
## 参考文章

* [《程序员的自我修养：链接、装载与库》](https://book.douban.com/subject/3652388//)
* [《深入理解计算机系统》](https://book.douban.com/subject/26912767/)







 






